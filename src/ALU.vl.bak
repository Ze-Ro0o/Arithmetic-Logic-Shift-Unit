/* 
 * Do not change Module name 
*/
module half_adder(sum, carry, a, b);
   input a, b;
   output sum, carry;
   xor(sum, a, b);
   and(carry, a, b);
endmodule

module full_adder(sum, carry, x, y, z);
   input x, y, z;
   output sum, carry;
   wire s1, c1, c2;
   half_adder h1(s1, c1, x, y);
   half_adder h2(sum, c2, s1, z);
   or(carry, c1, c2);
endmodule



/*
* functions:
*/

/*
* S = 00 -> A + B
* S = 01 -> A - B
* S = 10 -> A - 1
* S = 11 -> A + 1
*/
module arithmeticunit(D,A,B,S);
	output [4:0] D; //Result
	input [3:0]  A;  // Operand.
    input [3:0]  B;  // Operand.
	input [1:0]  S;  //selection lines
	
	wire [3:0] Bin;
	wire [3:0] Bnot;
	wire [4:0] carries;
	wire [3:0] ones;
	wire [3:0] zeros;
	
	buf(carries[0], S[0]);
	
	zero z(zeros,B);
	notop n1(ones,zeros);
	notop n2(Bnot,B);
	MUX4_4_1 m(Bin,B,Bnot,ones,zeros,S[0], S[1]);
	
	full_adder f1(D[0],carries[1],A[0],Bin[0],carries[0]);
	full_adder f2(D[1],carries[2],A[1],Bin[1],carries[1]);
	full_adder f3(D[2],carries[3],A[2],Bin[2],carries[2]);
	full_adder f4(D[3],carries[4],A[3],Bin[3],carries[3]);
	
	//ignoring carry in cases 01 and 10
	wire temp;
	xnor(temp, S[0], S[1]);
	and(D[4], carries[4], temp);
endmodule


module andop(Y, A, B);
   output [3:0] Y;  // Result.
   input [3:0]  A;  // Operand.
   input [3:0]  B;  // Operand.

   and(Y[0], A[0], B[0]);
   and(Y[1], A[1], B[1]);
   and(Y[2], A[2], B[2]);
   and(Y[3], A[3], B[3]);
endmodule // andop

module orop(Y, A, B);
   output [3:0] Y; // Result.
   input [3:0]  A; // Operand.
   input [3:0]  B; // Operand.

   or(Y[0], A[0], B[0]);
   or(Y[1], A[1], B[1]);
   or(Y[2], A[2], B[2]);
   or(Y[3], A[3], B[3]);
endmodule // orop

module xorop(Y, A, B);
   output [3:0] Y; // Result.
   input [3:0]  A; // Operand.
   input [3:0]  B; // Operand.

   xor(Y[0], A[0], B[0]);
   xor(Y[1], A[1], B[1]);
   xor(Y[2], A[2], B[2]);
   xor(Y[3], A[3], B[3]);
endmodule // xorop

module notop(Y, B);
   output [3:0] Y; // Result.
   input [3:0]  B; // Operand.

   not(Y[0], B[0]);
   not(Y[1], B[1]);
   not(Y[2], B[2]);
   not(Y[3], B[3]);
endmodule // notop

module zero(Z, A);
   output [3:0] Z; // Result. 
   input [3:0]  A; // Operand.

   wire [3:0] 	 Y; // operand's complement.
   
   not(Y[0], A[0]);
   not(Y[1], A[1]);
   not(Y[2], A[2]);
   not(Y[3], A[3]);
   andop an(Z, Y, A);
endmodule // zero

/*module MUX4_1(output x,input m1,input m2,input m3,input m4,input s1,input s0);
/*wire a,b,c,d,s0com,s1com;
and(a,s0com,s1com,m1);
and(b,s0com,s1,m2);
and(c,s0,s1com,m3);
and(d,s0,s1,m4);
or(x,a,b,c,d);
assign x = m1 & (~s0 & ~s1) |
m2 & (~s0 & s1) |
m3 & ( s0& ~s1) |
m4 & ( s1 & s0);
endmodule*/

module m41(out, a, b, c, d, s1, s0);

output out;
input a, b, c, d, s0, s1;
wire sobar, s1bar, T1, T2, T3, T4;

not (s0bar, s0), (s1bar, s1);
and (T1, a, s0bar, s1bar), (T2, b, s0bar, s1),(T3, c, s0, s1bar), (T4, d, s0, s1);
or(out, T1, T2, T3, T4);

endmodule

module MUX4_4_1(output[3:0] out,input[3:0] in1,input[3:0] in2,input[3:0] in3,input[3:0] in4,input s1,input s0);
m41 m1(out[0],in1[0],in2[0],in3[0],in4[0],s1,s0);
m41 m2(out[1],in1[1],in2[1],in3[1],in4[1],s1,s0);
m41 m3(out[2],in1[2],in2[2],in3[2],in4[2],s1,s0);
m41 m4(out[3],in1[3],in2[3],in3[3],in4[3],s1,s0);
endmodule


module main;

wire[4:0] a;
reg[3:0] b,c;
reg[1:0] d;

arithmeticunit ar(a,b,c,d);

  initial 
    begin
    b[3]=1;b[2]=0;b[1]=1;b[0]=1;
    c[3]=1;c[2]=0;c[1]=1;c[0]=1;
    d[1]=0;d[0]=0;
      $monitor("A[4]=%b, A[3]=%b, A[2]=%b, A[1]=%b, A[0]=%b", a[4], a[3], a[2], a[1], a[0]);
      $finish ; 
    end
endmodule